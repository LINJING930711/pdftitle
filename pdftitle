#!/usr/bin/env python
# -*- coding: utf-8 -*-

import getopt
import os
import re
import subprocess
import sys
from cStringIO import StringIO
try:
  from lxml import etree
  Parser = etree.XMLParser(recover=True)
except ImportError:
  import xml.etree.ElementTree as etree
  Parser = None


VERSION = '1.1'


def convertPDFToXML(Path):
  """Return XML string of converted PDF file."""
  Cmd = 'pdftohtml'
  Args = ['-xml', '-f', '1', '-l', '1', '-i', '-q', '-nodrm', '-hidden', '-stdout']
  Process = [Cmd] + Args + [Path]
  XMLString = subprocess.check_output(Process, stderr=open(os.devnull, 'w'))
  if not XMLString:
    ## PDF file can't be found, or is invalid, or is encrypted
    raise EOFError
  return etree.parse(StringIO(removeControlChars(XMLString)), Parser)


def removeControlChars(String):
  """Filter ASCII control characters as etree threats them as invalid"""
  return ''.join([i for i in String if ord(i) in [9, 10, 13] or ord(i) >= 32])


def fontSpecs(XMLData):
  """Return all font specifications in XML."""
  XMLFontSpecs = XMLData.findall('page[@number="1"]/fontspec[@id][@size]')
  return [FS.attrib for FS in XMLFontSpecs]


def sortedFontIds(FontSpecs):
  """Return sorted font specifications by size decending."""
  FontSpecs = sorted(FontSpecs, key=lambda x: int(x['size']), reverse=True)
  return [FS['id'] for FS in FontSpecs]


def textsById(XMLData, FontId):
  """Return text lines given font id."""
  TextElements = XMLData.findall('page[@number="1"]/text[@font="%s"]' % FontId)
  FirstPageTop = int(XMLData.findall('page[@number="1"]')[0].get('top'))
  return topAndTexts(TextElements, FirstPageTop)


def topAndTexts(TextElements, PageTop):
  """Return top position of first non-empty text line and all
  unformatted non-empty text lines.
  Example: {'top': 16, 'text': ['a','b','c']}"""
  TextLines = []
  Top = PageTop

  for TextElement in TextElements:
    TextLine = unformatAndStrip(TextElement)
    if not TextLine:
      continue
    T = int(TextElement.get('top'))
    if T < Top:
      continue
    Top = T
    TextLines.append(TextLine)

  if TextLines and Top > PageTop:
    return {'top': Top, 'texts': TextLines}
  else:
    return {}


def unformatAndStrip(TextElement):
  """Return non-empty unformatted text element."""
  return ''.join(TextElement.itertext()).strip()


def filterEmpties(TextBlocks, _Config):
  """Filter emtpy text blocks."""
  return [T for T in TextBlocks if T]


def filterMargin(TextBlocks, Config):
  """Filter text lines above certain top margin."""
  return [T for T in TextBlocks if T['top'] > Config['topMargin']]


def filterShorts(TextBlocks, Config):
  """Filter text lines which are too short thus unlikely titles."""
  return [T for T in TextBlocks if len(''.join(T['texts'])) >= Config['minLength']]


def formatUpperCase(Title, _Config):
  """Return the title in titlecase if all letters are uppercase."""
  return Title.title() if Title.isupper() else Title


def formatWeirdCase(Title, _Config):
  """Return the title in titlecase if all letters are uppercase."""
  return Title.title() if isweirdcase(Title) else Title


def isweirdcase(String):
  """Returns a boolean if given String has "weird" cases in case letters.
  Example: isweirdcase('A FAult-tolerAnt token BAsed Algorithm') == True"""
  for i in range(len(String)-2):
    if String[i].isalpha() and (
       String[i+1].isupper() and String[i+2].islower() or
       String[i+1].islower() and String[i+2].isupper()):
      return True
  return False


def formatRemoveMultiSpaces(Title, _Config):
  """Return the title with not more than one space per word separation."""
  return ' '.join(Title.split()).replace(' :', ':')


def formatRemoveLinebreakDash(Title, _Config):
  """Return the title without linebreak dash."""
  return re.sub(r'(\S)- (.+)', r'\1-\2', Title)


def title(TextBlocks, Config):
  """Return title from list. Either all non-empty texts with font id
  or just first."""
  for TextBlock in TextBlocks:
    if Config['multiline']:
      return ' '.join(TextBlock['texts'])
    else:
      return TextBlock['texts'][0]
  return None


def apply(Funs, Value, Config):
  """Return a value after applying a list of functions until list or value is
  empty."""
  if not (Funs and Value):
    return Value
  NewValue = Funs[0](Value, Config)
  return apply(Funs[1:], NewValue, Config)


def extractTitle(Path, Config):
  """Return title in PDF article after applying rules and filters."""
  Filters = [
    filterEmpties,
    filterMargin,
    filterShorts,
    title
  ]
  Formatters = [
    formatUpperCase,
    formatWeirdCase,
    formatRemoveMultiSpaces,
    formatRemoveLinebreakDash
  ]
  XMLData = convertPDFToXML(Path)
  FontIds = sortedFontIds(fontSpecs(XMLData))
  Texts = [textsById(XMLData, FontId) for FontId in FontIds]
  Title = apply(Filters + Formatters, Texts, Config)
  return Title


def usage():
  Basename = os.path.basename(sys.argv[0])
  return '''Usage: %s [options...] <file>
Options:
 -t, --top=<n>     Top margin start to search for title (default: 80)
 -l, --length=<n>  Min acceptable title length (default: 5)
 -m, --multi       Concatenate multiple title lines found (default)
 -s, --single      Only use first title line found
 -v, --version     Show version info
 -h, --help        Show usage screen''' % Basename


def exit(Code, Str):
  if Code:
    sys.stderr.write(Str + '\n')
  else:
    print Str
  return Code


def main(Argv=None):
  """Find first non-empty text in PDF File with largest size and return as
  unformatted string."""
  Argv = Argv or sys.argv[1:]

  ## Argument parsing
  try:
    LongOpts = ['help', 'version', 'multi', 'single', 'top=', 'length=']
    Opts, Args = getopt.getopt(Argv, 'hvmst:l:', LongOpts)
  except getopt.GetoptError as err:
    return exit(2, str(err) + '\n' + usage())

  Multiline = True
  TopMargin = 75
  MinLength = 15

  try:
    for o, a in Opts:
      if (o in ['-h', '--help']):
        return exit(0, usage())
      elif (o in ['-v', '--version']):
        return exit(0, VERSION)
      elif (o in ['-m', '--multi']):
        Multiline = True
      elif (o in ['-s', '--single']):
        Multiline = False
      elif (o in ['-t', '--top']):
        TopMargin = int(a)
        if TopMargin < 0:
          raise AssertionError
      elif (o in ['-l', '--length']):
        MinLength = int(a)
        if MinLength < 0:
          raise AssertionError
      else:
        return exit(2, 'Invalid argument')

    Config = {
      'multiline': Multiline,
      'topMargin': TopMargin,
      'minLength': MinLength
    }

    if not len(Args):
      return exit(2, usage())
    Path = Args[0]
    if not os.path.isfile(Path):
      raise IOError
    Title = extractTitle(Path, Config)
    if not Title:
      return exit(1, 'No title found')
    else:
      ## Have to encode output when piping script. See: http://goo.gl/h0ql0
      print Title.encode('utf-8')
  except AssertionError as e:
    return exit(2, 'Invalid argument value' + '\n' + usage())
  except IOError:
    return exit(3, 'No such file')
  except OSError:
    return exit(4, 'pdftohtml not found')
  except EOFError:
    return exit(5, 'Could not convert PDF to XML')
  except etree.ParseError:
    return exit(6, 'Could not parse XML')
  except:
    return exit(8, 'Unknown error')

if __name__ == '__main__':
  sys.exit(main())
