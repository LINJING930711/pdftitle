#!/usr/bin/env python

import os, sys, getopt, subprocess
from xml.etree import ElementTree

VERSION = '1.0'


def convertPDFToXML(Path):
  """Return XML string of converted PDF file."""
  Args = ['pdftohtml', '-xml', '-f', '1', '-l', '1', '-q', '-i', '-stdout', Path]
  XMLString = subprocess.check_output(Args)
  if not XMLString: raise EOFError('Conversion failed')
  return ElementTree.fromstring(XMLString)
  
def fontSpecs(XMLData):
  """Return all font specifications in XML."""
  XMLFontSpecs = XMLData.findall('page/fontspec[@id][@size]')
  return [FS.attrib for FS in XMLFontSpecs]

def sortFontIds(FontSpecs):
  """Return sorted font specifications by size decending."""
  FontSpecs = sorted(FontSpecs, key=lambda x: int(x['size']), reverse=True)
  return [FS['id'] for FS in FontSpecs]

def stripTexts(XMLData, FontId, TopMargin=80):
  """Return non-empty unformatted text items given font id."""
  Texts = XMLData.findall('page/text[@font="%s"]' % FontId)
  ## Do not include texts above a certain top margin
  MinHeightTexts = filter(lambda x: int(x.get('top')) > TopMargin, Texts)
  ## Strip possible formatting tags and check if empty
  return [''.join(T.itertext()).strip() for T in MinHeightTexts]

def title(TextList, Multiline=True):
  """Return title from list. Either all non-empty texts with font id
  or just first."""
  for Texts in TextList:
    NonEmptyTexts = filter(lambda Text: Text.strip(), Texts)
    if not NonEmptyTexts: continue
    return ' '.join(NonEmptyTexts) if Multiline else NonEmptyTexts[0]
  return None

def extractTitle(Path, Config):
  """Return title in PDF article after applying rules and filters."""
  XMLData = convertPDFToXML(Path)
  FontIds = sortedFontIds(fontSpecs(XMLData))
  Texts0  = [textsById(XMLData, FontId) for FontId in FontIds]
  Texts1  = filterEmpties(Texts0)
  Texts2  = filterMargin(Texts1, Config['topMargin'])
  Texts3  = filterShorts(Texts2, Config['minLength'])
  Title   = title(Texts3, Config['multiline'])
  return Title


def usage():
  print 'Usage: %s [options...] <file>' % os.path.basename(sys.argv[0])
  print
  print 'Options:'
  print ' -h, --help       Show usage screen'
  print ' -v, --version    Show version info'
  print ' -m, --multi      Concatenate multiple title lines found (default)'
  print ' -s, --single     Only use first title line found'
  print ' -t, --top=<n>    Points from top to skip when searching for title (default: 80)'

def main(Argv=None):
  """Find first non-empty text in PDF File with largest size and return as
  unformatted string."""
  if Argv is None:
      Argv = sys.argv[1:]

  ## Argument parsing
  try:
    LongOpts = ['help', 'version', 'multi', 'single', 'top=', 'length=']
    Opts, Args = getopt.getopt(Argv, 'hvmst:l:', LongOpts)
  except getopt.GetoptError as err:
    print str(err)
    usage()
    return 1

  Multiline = True
  TopMargin = 80
  
  try:
    for o, a in Opts:
      if (o in ['-h', '--help']):
        usage()
        return 0
      elif (o in ['-v', '--version']):
        print VERSION
        return 0
      elif (o in ['-m', '--multi']):
        Multiline = True
      elif (o in ['-s', '--single']):
        Multiline = False
      elif (o in ['-t', '--top']):
        TopMargin = int(a)
        if TopMargin < 0: raise ValueError
      else:
        print 'Invalid argument'
        usage()
        return 2

    if len(Args) >= 1:
      Path = Args[0]
    else:
      usage()
      return 2

    if not os.path.isfile(Path): raise IOError
    Title = extractTitle(Path, Config)

    if Title:
      print Title
    else:
      print 'No title found'
      return 1
  except ValueError:
    print 'Invalid argument value'
    usage()
    return 2
  except IOError:
    print 'No such file'
    return 3
  except OSError:
    print 'pdftohtml not found'
    return 4
  except EOFError:
    print 'Could not convert PDF to XML'
    return 5
  except ElementTree.ParseError:
    print 'Could not parse XML'
    return 6
  except:
    print 'Unknown error'
    return 8

if __name__ == '__main__':
  sys.exit(main())
