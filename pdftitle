#!/usr/bin/env python

import os, sys, getopt, subprocess
from xml.etree import ElementTree

VERSION = '1.0'


def convertPDFToXML(Path):
  """Return XML string of converted PDF file."""
  Args = ['pdftohtml', '-xml', '-f', '1', '-l', '1', '-q', '-i', '-stdout', Path]
  XMLString = subprocess.check_output(Args)
  if not XMLString: raise EOFError
  return ElementTree.fromstring(XMLString)
  
def fontSpecs(XMLData):
  """Return all font specifications in XML."""
  XMLFontSpecs = XMLData.findall('page[@number="1"]/fontspec[@id][@size]')
  return [FS.attrib for FS in XMLFontSpecs]

def sortedFontIds(FontSpecs):
  """Return sorted font specifications by size decending."""
  FontSpecs = sorted(FontSpecs, key=lambda x: int(x['size']), reverse=True)
  return [FS['id'] for FS in FontSpecs]

def textsById(XMLData, FontId):
  """Return text lines given font id."""
  TextElements = XMLData.findall('page[@number="1"]/text[@font="%s"]' % FontId)
  FirstPageTop = int(XMLData.findall('page[@number="1"]')[0].get('top'))
  return topAndTexts(TextElements, FirstPageTop)

def topAndTexts(TextElements, PageTop):
  """Return top position of first non-empty text line and all
  unformatted non-empty text lines.
  Example: {'top': 16, 'text': ['a','b','c']}"""
  TextLines = []
  Top = PageTop

  for TextElement in TextElements:
    TextLine = unformatAndStrip(TextElement)
    if not TextLine: continue
    T = int(TextElement.get('top'))
    T = int(TextElement.get('top'))
    if T < Top or Top == PageTop: Top = T
    TextLines.append(TextLine)
  
  if TextLines and Top > PageTop:
    return {'top': Top, 'texts': TextLines}
  else:
    return {}

def unformatAndStrip(TextElement):
  """Return non-empty unformatted text element."""
  return ''.join(TextElement.itertext()).strip()

## Filters

def filterEmpties(TextBlocks):
  """Filter emtpy text blocks."""
  return [T for T in TextBlocks if T]

def filterMargin(TextBlocks, TopMargin=80):
  """Filter text lines above certain top margin."""
  return [T for T in TextBlocks if T['top'] > TopMargin]

def filterShorts(TextBlocks, MinLength=5):
  """Filter text lines which are too short thus unlikely titles."""
  return [T for T in TextBlocks if len(''.join(T['texts'])) >= MinLength]


def title(TextBlocks, Multiline=True):
  """Return title from list. Either all non-empty texts with font id
  or just first."""
  for TextBlock in TextBlocks:
    return ' '.join(TextBlock['texts']) if Multiline else TextBlock['texts'][0]
  return None


def extractTitle(Path, Config):
  """Return title in PDF article after applying rules and filters."""
  XMLData = convertPDFToXML(Path)
  FontIds = sortedFontIds(fontSpecs(XMLData))
  Texts0  = [textsById(XMLData, FontId) for FontId in FontIds]
  Texts1  = filterEmpties(Texts0)
  Texts2  = filterMargin(Texts1, Config['topMargin'])
  Texts3  = filterShorts(Texts2, Config['minLength'])
  Title   = title(Texts3, Config['multiline'])
  return Title


def usage():
  return '''Usage: %s [options...] <file>
Options:
 -h, --help        Show usage screen
 -v, --version     Show version info
 -m, --multi       Concatenate multiple title lines found (default)
 -s, --single      Only use first title line found
 -t, --top=<n>     Points from top to skip when searching for title (default: 80)
 -l, --length=<n>  Min title length to accept (default: 5)''' % os.path.basename(sys.argv[0])

def exit(Code, Str):
  if Code: sys.stderr.write(Str + '\n')
  else: print Str
  return Code

def main(Argv=None):
  """Find first non-empty text in PDF File with largest size and return as
  unformatted string."""
  Argv = Argv or sys.argv[1:]

  ## Argument parsing
  try:
    LongOpts = ['help', 'version', 'multi', 'single', 'top=', 'length=']
    Opts, Args = getopt.getopt(Argv, 'hvmst:l:', LongOpts)
  except getopt.GetoptError as err:
    return exit(2, str(err) + '\n' + usage())

  Multiline = True
  TopMargin = 80
  MinLength = 5
  
  try:
    for o, a in Opts:
      if   (o in ['-h', '--help']):    return exit(0, usage())
      elif (o in ['-v', '--version']): return exit(0, VERSION)
      elif (o in ['-m', '--multi']):   Multiline = True
      elif (o in ['-s', '--single']):  Multiline = False
      elif (o in ['-t', '--top']):
        TopMargin = int(a)
        if TopMargin < 0: raise AssertionError
      elif (o in ['-l', '--length']):
        MinLength = int(a)
        if MinLength < 0: raise AssertionError
      else: return exit(2, 'Invalid argument')
    
    Config = {
      'multiline': Multiline,
      'topMargin': TopMargin,
      'minLength': MinLength
    }

    if not len(Args): return exit(2, usage())
    Path = Args[0]
    if not os.path.isfile(Path): raise IOError
    Title = extractTitle(Path, Config)
    if not Title: return exit(1, 'No title found')
    print Title
  except AssertionError as e:
    print e
    return exit(2, 'Invalid argument value' + '\n' + usage())
  except IOError: return exit(3, 'No such file')
  except OSError: return exit(4, 'pdftohtml not found')
  except EOFError: return exit(5, 'Could not convert PDF to XML')
  except ElementTree.ParseError: return exit(6, 'Could not parse XML')
  except: return exit(8, 'Unknown error')

if __name__ == '__main__':
  sys.exit(main())
